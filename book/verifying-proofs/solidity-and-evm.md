# Verifying Proofs: Solidity & EVM

SP1 recently added support for verifying proofs for onchain usecases. To see an end-to-end example
of using SP1 for on-chain usecases, refer to the [SP1 Project Template](https://github.com/succinctlabs/sp1-project-template/tree/main).

## Generating a Groth16 Proof

By default, the proofs generated by SP1 are not verifiable onchain, as they are non-constant size and STARK verification on Ethereum is very expensive. To generate a proof that can be verified onchain, we use performant STARK recursion to combine SP1 shard proofs into a single STARK proof and then wrap that in a SNARK proof. Our `ProverClient` has a function for this called `prove_groth16`. Behind the scenes, this function will first generate a normal SP1 proof, then recursively combine all of them into a single proof using the STARK recursion protocol. Finally, the proof is wrapped in a SNARK proof using Groth16.

**Due to the fact that Groth16 proofs require a trusted setup, the Groth16 prover is only guaranteed to work on official releases of SP1 (i.e., `v.1.0.0-testnet`).**


### Example

```rust,noplayground
{{#include ../../examples/fibonacci/script/bin/groth16.rs}}
```

You can run the above script with `RUST_LOG=info cargo run --bin groth16 --release` in `examples/fibonacci/script`.

## Exporting the Verifier Contract

To export the verifier contract, you can use the export function in the `sp1_sdk` crate.

### Example

```rust,noplayground
//! Builds the proving artifacts and exports the solidity verifier.
//!
//! You can run this script using the following command:
//! ```shell
//! RUST_LOG=info cargo run --package fibonacci-script --bin artifacts --release
//! ```

use std::path::PathBuf;

fn main() {
    let contracts_src_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("../contracts/src");
    sp1_sdk::artifacts::export_solidity_groth16_verifier(contracts_src_dir)
        .expect("failed to export verifier");
}
```