# Quickstart

In this section, we will show you how to create a simple Fibonacci program using the SP1 zkVM.

## Create Project

The first step is to create a new project using the `cargo prove new <name>` command. This command will create a new folder in your current directory.

```bash
cargo prove new fibonacci
cd fibonacci
```

This will create a new project with the following structure:

```
.
├── program
│   ├── Cargo.toml
│   ├── elf
│   └── src
│       └── main.rs
└── script
    ├── Cargo.toml
    └── src
        └── main.rs

6 directories, 4 files
```

There are 2 directories (each a crate) in the project: 
- `program`: the source code that will be proven inside the zkVM.
- `script`: code that contains proof generation and verification code.

We recommend you install the [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer) extension.
Note that if you use `cargo prove new` inside a monorepo, you will need to add the manifest file to `rust-analyzer.linkedProjects` to get full IDE support.

## Build Program

Before we can run the program inside the zkVM, we must compile it to a RISCV executable using the `succinct` Rust toolchain. The `cargo prove` CLI tool exposes a `build` command which you can run at the root of the `program` directory to do this. 

The program is a very simple program to compute the `n`-th Fibonacci number. 

```bash
cd program
cargo prove build
```

The resulting compiled executable is called an [ELF (Executable and Linkable Format)](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) and contains bytecode that can be executed by the SP1 zkVM.


After running the above command, you can verify that the ELF was generated by looking in the `elf` directory and looking for a file called `riscv32im-succinct-zkvm-elf`:
```bash
ls elf # should show riscv32im-succinct-zkvm-elf
```

## Generate Proof

To generate a proof, we take the ELF file that was generated in the previous step and execute it within the SP1 zkVM. The code in the `script` directory is already scaffolded with a script that has logic to generate a proof, save the proof to disk, and verify it.

```bash
cd ../script
RUST_LOG=info cargo run --release
```

The output should show
```
...
    Compiling fibonacci-script v0.1.0 (/Users/umaroy/Documents/fibonacci/script)
    Finished release [optimized] target(s) in 26.14s
    Running `target/release/fibonacci-script`
a: 205697230343233228174223751303346572685
b: 332825110087067562321196029789634457848
successfully generated and verified proof for the program!
```

The program by default is quite small, so proof generation will only take a few seconds locally. After it completes, the proof will be saved in the `proof-with-io.json` file and also be verified for correctness.

You can play around with how many rounds of Fibonacci are executed by playing around with `n` (by default set to `186`) in the file `script/src/main.rs`. Integer overflow will cause larger `n` to result in non-fibonacci output, although the proof will still be generated and verified.